package ch.unibe.iam.scg.minijava.prettyprint;

import ch.unibe.iam.scg.javacc.syntaxtree.Assignment;
import ch.unibe.iam.scg.javacc.syntaxtree.BinaryOperator;
import ch.unibe.iam.scg.javacc.syntaxtree.INode;
import ch.unibe.iam.scg.javacc.syntaxtree.Identifier;
import ch.unibe.iam.scg.javacc.syntaxtree.New;
import ch.unibe.iam.scg.javacc.syntaxtree.NodeListOptional;
import ch.unibe.iam.scg.javacc.syntaxtree.NodeToken;
import ch.unibe.iam.scg.javacc.syntaxtree.StatementList;
import ch.unibe.iam.scg.javacc.syntaxtree.Type;
import ch.unibe.iam.scg.javacc.syntaxtree.VarDeclaration;
import ch.unibe.iam.scg.javacc.visitor.DepthFirstVoidVisitor;
import ch.unibe.iam.scg.minijava.ast.AstNode;

/**
 * Change at will!
 * 
 * @author kursjan
 *
 */
public class PrettyPrinter extends DepthFirstVoidVisitor
{
	private StringBuffer buffer;
	
    public PrettyPrinter() {
		super();
		this.buffer = new StringBuffer();
	}

    public String prettyPrint(Object node)
    {
        INode n=  (INode) node;
        n.accept(this);
        return buffer.toString();
    }
    
    /**
     * Visits a {@link NodeToken} node.
     *
     * @param n - the node to visit
     */
    @Override
    public void visit(final NodeToken n) {
      buffer.append(n.tokenImage);
    }
    
    /**
     * Visits a {@link VarDeclaration} node, whose children are the following :
     * <p>
     * f0 -> Type()<br>
     * f1 -> Identifier()<br>
     * f2 -> <SEMICOLON><br>
     *
     * @param n - the node to visit
     */
    @Override
    public void visit(final VarDeclaration n) {
      // f0 -> Type()
      final Type n0 = n.f0;
      n0.accept(this);      
      makeSpace();
      // f1 -> Identifier()
      final Identifier n1 = n.f1;
      n1.accept(this);
      // f2 -> <SEMICOLON>
      final NodeToken n2 = n.f2;
      n2.accept(this);
    }
    
    /**
     * Visits a {@link BinaryOperator} node, whose child is the following :
     * <p>
     * f0 -> <BINARY_OPERATOR><br>
     *
     * @param n - the node to visit
     */
    @Override
    public void visit(final BinaryOperator n) {
      // f0 -> <BINARY_OPERATOR>
      makeSpace();
      final NodeToken n0 = n.f0;
      n0.accept(this);
      makeSpace();
    }
    
    /**
	   * Visits a {@link Assignment} node, whose child is the following :
	   * <p>
	   * f0 -> <EQUALS_SIGN><br>
	   *
	   * @param n - the node to visit
	   */
	  @Override
	  public void visit(final Assignment n) {
		makeSpace();
	    // f0 -> <EQUALS_SIGN>
	    final NodeToken n0 = n.f0;
	    n0.accept(this);
	    makeSpace();
	  }
    
    /**
     * Visits a {@link New} node, whose child is the following :
     * <p>
     * f0 -> <NEW><br>
     *
     * @param n - the node to visit
     */
    @Override
    public void visit(final New n) {
      // f0 -> <NEW>
      final NodeToken n0 = n.f0;
      n0.accept(this);
      makeSpace();
    }
    
    /**
     * Visits a {@link StatementList} node, whose children are the following :
     * <p>
     * f0 -> <BRACE_LEFT><br>
     * f1 -> ( Statement() )*<br>
     * f2 -> <BRACE_RIGHT><br>
     *
     * @param n - the node to visit
     */
    @Override
    public void visit(final StatementList n) {
      // f0 -> <BRACE_LEFT>
      final NodeToken n0 = n.f0;
      n0.accept(this);
      makeNewLine();
      // f1 -> ( Statement() )*
      final NodeListOptional n1 = n.f1;
      if (n1.present()) {
        for (int i = 0; i < n1.size(); i++) {
          final INode nloeai = n1.elementAt(i);
          nloeai.accept(this);
          makeNewLine();
        }
      }
      // f2 -> <BRACE_RIGHT>
      final NodeToken n2 = n.f2;
      n2.accept(this);
    }

	private void makeNewLine() {
		buffer.append("\n");
		
	}

	private void makeSpace() {
		buffer.append(" ");
	}
	
	 

}
