package ch.unibe.iam.scg.minijava.prettyprint;

import ch.unibe.iam.scg.javacc.syntaxtree.Assignment;
import ch.unibe.iam.scg.javacc.syntaxtree.BinaryOperator;
import ch.unibe.iam.scg.javacc.syntaxtree.BooleanType;
import ch.unibe.iam.scg.javacc.syntaxtree.ClassDeclaration;
import ch.unibe.iam.scg.javacc.syntaxtree.INode;
import ch.unibe.iam.scg.javacc.syntaxtree.Identifier;
import ch.unibe.iam.scg.javacc.syntaxtree.New;
import ch.unibe.iam.scg.javacc.syntaxtree.NodeListOptional;
import ch.unibe.iam.scg.javacc.syntaxtree.NodeOptional;
import ch.unibe.iam.scg.javacc.syntaxtree.NodeSequence;
import ch.unibe.iam.scg.javacc.syntaxtree.NodeToken;
import ch.unibe.iam.scg.javacc.syntaxtree.StatementList;
import ch.unibe.iam.scg.javacc.syntaxtree.Type;
import ch.unibe.iam.scg.javacc.syntaxtree.VarDeclaration;
import ch.unibe.iam.scg.javacc.visitor.DepthFirstVoidVisitor;
import ch.unibe.iam.scg.minijava.ast.AstNode;

/**
 * Change at will!
 * 
 * @author kursjan
 *
 */
public class PrettyPrinter extends DepthFirstVoidVisitor
{
	private StringBuffer buffer;
	private int indentCount;
	
    public PrettyPrinter() {
		super();
		this.buffer = new StringBuffer();
		indentCount=0;
	}

    public String prettyPrint(Object node)
    {
        INode n=  (INode) node;
        n.accept(this);
        return buffer.toString();
    }
    
    /**
     * Visits a {@link NodeToken} node.
     *
     * @param n - the node to visit
     */
    @Override
    public void visit(final NodeToken n) {
      buffer.append(n.tokenImage);
    }
    
    /**
     * Visits a {@link VarDeclaration} node, whose children are the following :
     * <p>
     * f0 -> Type()<br>
     * f1 -> Identifier()<br>
     * f2 -> <SEMICOLON><br>
     *
     * @param n - the node to visit
     */
    @Override
    public void visit(final VarDeclaration n) {
      // f0 -> Type()
      final Type n0 = n.f0;
      n0.accept(this);      
      makeSpace();
      // f1 -> Identifier()
      final Identifier n1 = n.f1;
      n1.accept(this);
      // f2 -> <SEMICOLON>
      final NodeToken n2 = n.f2;
      n2.accept(this);
    }
    
    /**
     * Visits a {@link BinaryOperator} node, whose child is the following :
     * <p>
     * f0 -> <BINARY_OPERATOR><br>
     *
     * @param n - the node to visit
     */
    @Override
    public void visit(final BinaryOperator n) {
      // f0 -> <BINARY_OPERATOR>
      makeSpace();
      final NodeToken n0 = n.f0;
      n0.accept(this);
      makeSpace();
    }
    
    /**
	   * Visits a {@link Assignment} node, whose child is the following :
	   * <p>
	   * f0 -> <EQUALS_SIGN><br>
	   *
	   * @param n - the node to visit
	   */
	  @Override
	  public void visit(final Assignment n) {
		makeSpace();
	    // f0 -> <EQUALS_SIGN>
	    final NodeToken n0 = n.f0;
	    n0.accept(this);
	    makeSpace();
	  }
    
    /**
     * Visits a {@link New} node, whose child is the following :
     * <p>
     * f0 -> <NEW><br>
     *
     * @param n - the node to visit
     */
    @Override
    public void visit(final New n) {
      // f0 -> <NEW>
      final NodeToken n0 = n.f0;
      n0.accept(this);
      makeSpace();
    }
    
    /**
     * Visits a {@link StatementList} node, whose children are the following :
     * <p>
     * f0 -> <BRACE_LEFT><br>
     * f1 -> ( Statement() )*<br>
     * f2 -> <BRACE_RIGHT><br>
     *
     * @param n - the node to visit
     */
    @Override
    public void visit(final StatementList n) {
      // f0 -> <BRACE_LEFT>
      final NodeToken n0 = n.f0;
      n0.accept(this);
      makeNewLine(indentCount);
      // f1 -> ( Statement() )*
      final NodeListOptional n1 = n.f1;
      if (n1.present()) {
        for (int i = 0; i < n1.size(); i++) {
          makeTab();	
          final INode nloeai = n1.elementAt(i);
          nloeai.accept(this);
          makeNewLine(indentCount);
        }
      }
      // f2 -> <BRACE_RIGHT>
      final NodeToken n2 = n.f2;
      n2.accept(this);
    }
    
    /**
     * Visits a {@link BooleanType} node, whose child is the following :
     * <p>
     * f0 -> <BOOLEAN_TYPE><br>
     *
     * @param n - the node to visit
     */
    @Override
    public void visit(final BooleanType n) {
    	buffer.append("bool");
    }
    
    /**
     * Visits a {@link ClassDeclaration} node, whose children are the following :
     * <p>
     * f0 -> <CLASS><br>
     * f1 -> Identifier()<br>
     * f2 -> ( #0 <EXTENDS> #1 Identifier() )?<br>
     * f3 -> <BRACE_LEFT><br>
     * f4 -> ( VarDeclaration() )*<br>
     * f5 -> ( MethodDeclaration() )*<br>
     * f6 -> <BRACE_RIGHT><br>
     *
     * @param n - the node to visit
     */
    @Override
    public void visit(final ClassDeclaration n) {
      // f0 -> <CLASS>
      final NodeToken n0 = n.f0;
      n0.accept(this);
      makeSpace();
      // f1 -> Identifier()
      final Identifier n1 = n.f1;
      n1.accept(this);
      makeSpace();
      // f2 -> ( #0 <EXTENDS> #1 Identifier() )?
      final NodeOptional n2 = n.f2;
      if (n2.present()) {
        final NodeSequence seq = (NodeSequence) n2.node;
        // #0 <EXTENDS>
        final INode seq1 = seq.elementAt(0);
        seq1.accept(this);
        makeSpace();
        // #1 Identifier()
        final INode seq2 = seq.elementAt(1);
        seq2.accept(this);
        makeSpace();
      }
      // f3 -> <BRACE_LEFT>
      final NodeToken n3 = n.f3;
      n3.accept(this);
      indentCount++;
      makeNewLine(indentCount);
      // f4 -> ( VarDeclaration() )*
      final NodeListOptional n4 = n.f4;
      if (n4.present()) {
        for (int i = 0; i < n4.size(); i++) {
          makeNewLine(indentCount);
          final INode nloeai = n4.elementAt(i);
          nloeai.accept(this);
        }
      }
      // f5 -> ( MethodDeclaration() )*
      final NodeListOptional n5 = n.f5;
      if (n5.present()) {
        for (int i = 0; i < n5.size(); i++) {
          makeNewLine(indentCount);
          final INode nloeai = n5.elementAt(i);
          nloeai.accept(this);
        }
      }
      indentCount--;
      makeNewLine(indentCount);
      // f6 -> <BRACE_RIGHT>
      final NodeToken n6 = n.f6;
      n6.accept(this);
    }


	private void makeNewLine(int numTabs) {
		buffer.append("\n");
		for(int i=numTabs;i>0;i--)
			makeTab();
	}

	private void makeTab() {
		buffer.append("    ");	
	}

	private void makeSpace() {
		buffer.append(" ");
	}
	
	 

}
