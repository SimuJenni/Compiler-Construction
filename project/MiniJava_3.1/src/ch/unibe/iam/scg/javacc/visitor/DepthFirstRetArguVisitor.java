/* Generated by JTB 1.4.9 */
package ch.unibe.iam.scg.javacc.visitor;

import ch.unibe.iam.scg.javacc.syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first order.<br>
 * In your "RetArgu" visitors extend this class and override part or all of these methods.
 *
 * @param <R> - The user return information type
 * @param <A> - The user argument type
 */
public class DepthFirstRetArguVisitor<R, A> implements IRetArguVisitor<R, A> {


  /*
   * Base nodes classes visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link NodeChoice} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeChoice n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    final R nRes = n.choice.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link NodeList} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeList n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      @SuppressWarnings("unused")
      final R sRes = e.next().accept(this, argu);
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeListOptional} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeListOptional n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    if (n.present()) {
      R nRes = null;
      for (final Iterator<INode> e = n.elements(); e.hasNext();) {
        @SuppressWarnings("unused")
        R sRes = e.next().accept(this, argu);
        }
      return nRes;
    } else
      return null;
  }

  /**
   * Visits a {@link NodeOptional} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeOptional n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    if (n.present()) {
      final R nRes = n.node.accept(this, argu);
      return nRes;
    } else
      return null;
  }

  /**
   * Visits a {@link NodeSequence} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeSequence n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      @SuppressWarnings("unused")
      R subRet = e.next().accept(this, argu);
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeTCF} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeTCF n, @SuppressWarnings("unused") final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return nRes;
  }

  /**
   * Visits a {@link NodeToken} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeToken n, @SuppressWarnings("unused") final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return nRes;
  }

  /*
   * User grammar generated visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link Goal} node, whose children are the following :
   * <p>
   * f0 -> MainClass()<br>
   * f1 -> ( ClassDeclaration() )*<br>
   * f2 -> <EOF><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final Goal n, final A argu) {
    R nRes = null;
    // f0 -> MainClass()
    final MainClass n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> ( ClassDeclaration() )*
    final NodeListOptional n1 = n.f1;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode nloeai = n1.elementAt(i);
        nRes = nloeai.accept(this, argu);
      }
    }
    // f2 -> <EOF>
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link MainClass} node, whose children are the following :
   * <p>
   * f0 -> <CLASS><br>
   * f1 -> Identifier()<br>
   * f2 -> <BRACE_LEFT><br>
   * f3 -> MainMethodDeclaration()<br>
   * f4 -> <BRACE_RIGHT><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final MainClass n, final A argu) {
    R nRes = null;
    // f0 -> <CLASS>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> Identifier()
    final Identifier n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> <BRACE_LEFT>
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    // f3 -> MainMethodDeclaration()
    final MainMethodDeclaration n3 = n.f3;
    nRes = n3.accept(this, argu);
    // f4 -> <BRACE_RIGHT>
    final NodeToken n4 = n.f4;
    nRes = n4.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link MainMethodDeclaration} node, whose children are the following :
   * <p>
   * f0 -> <PUBLIC_MODIFIER><br>
   * f1 -> <STATIC_MODIFIER><br>
   * f2 -> <VOID_TYPE><br>
   * f3 -> <MAIN_METHOD_NAME><br>
   * f4 -> <PARENTHESIS_LEFT><br>
   * f5 -> <STRING_TYPE><br>
   * f6 -> <BRACKET_LEFT><br>
   * f7 -> <BRACKET_RIGHT><br>
   * f8 -> Identifier()<br>
   * f9 -> <PARENTHESIS_RIGHT><br>
   * f10 -> <BRACE_LEFT><br>
   * f11 -> ( Statement() )?<br>
   * f12 -> <BRACE_RIGHT><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final MainMethodDeclaration n, final A argu) {
    R nRes = null;
    // f0 -> <PUBLIC_MODIFIER>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> <STATIC_MODIFIER>
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> <VOID_TYPE>
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    // f3 -> <MAIN_METHOD_NAME>
    final NodeToken n3 = n.f3;
    nRes = n3.accept(this, argu);
    // f4 -> <PARENTHESIS_LEFT>
    final NodeToken n4 = n.f4;
    nRes = n4.accept(this, argu);
    // f5 -> <STRING_TYPE>
    final NodeToken n5 = n.f5;
    nRes = n5.accept(this, argu);
    // f6 -> <BRACKET_LEFT>
    final NodeToken n6 = n.f6;
    nRes = n6.accept(this, argu);
    // f7 -> <BRACKET_RIGHT>
    final NodeToken n7 = n.f7;
    nRes = n7.accept(this, argu);
    // f8 -> Identifier()
    final Identifier n8 = n.f8;
    nRes = n8.accept(this, argu);
    // f9 -> <PARENTHESIS_RIGHT>
    final NodeToken n9 = n.f9;
    nRes = n9.accept(this, argu);
    // f10 -> <BRACE_LEFT>
    final NodeToken n10 = n.f10;
    nRes = n10.accept(this, argu);
    // f11 -> ( Statement() )?
    final NodeOptional n11 = n.f11;
    if (n11.present()) {
      nRes = n11.accept(this, argu);
    }
    // f12 -> <BRACE_RIGHT>
    final NodeToken n12 = n.f12;
    nRes = n12.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link ClassDeclaration} node, whose children are the following :
   * <p>
   * f0 -> <CLASS><br>
   * f1 -> Identifier()<br>
   * f2 -> ( #0 <EXTENDS> #1 Identifier() )?<br>
   * f3 -> <BRACE_LEFT><br>
   * f4 -> ( VarDeclaration() )*<br>
   * f5 -> ( MethodDeclaration() )*<br>
   * f6 -> <BRACE_RIGHT><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final ClassDeclaration n, final A argu) {
    R nRes = null;
    // f0 -> <CLASS>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> Identifier()
    final Identifier n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> ( #0 <EXTENDS> #1 Identifier() )?
    final NodeOptional n2 = n.f2;
    if (n2.present()) {
      final NodeSequence seq = (NodeSequence) n2.node;
      // #0 <EXTENDS>
      final INode seq1 = seq.elementAt(0);
      nRes = seq1.accept(this, argu);
      // #1 Identifier()
      final INode seq2 = seq.elementAt(1);
      nRes = seq2.accept(this, argu);
    }
    // f3 -> <BRACE_LEFT>
    final NodeToken n3 = n.f3;
    nRes = n3.accept(this, argu);
    // f4 -> ( VarDeclaration() )*
    final NodeListOptional n4 = n.f4;
    if (n4.present()) {
      for (int i = 0; i < n4.size(); i++) {
        final INode nloeai = n4.elementAt(i);
        nRes = nloeai.accept(this, argu);
      }
    }
    // f5 -> ( MethodDeclaration() )*
    final NodeListOptional n5 = n.f5;
    if (n5.present()) {
      for (int i = 0; i < n5.size(); i++) {
        final INode nloeai = n5.elementAt(i);
        nRes = nloeai.accept(this, argu);
      }
    }
    // f6 -> <BRACE_RIGHT>
    final NodeToken n6 = n.f6;
    nRes = n6.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link VarDeclaration} node, whose children are the following :
   * <p>
   * f0 -> TypedDeclaration()<br>
   * f1 -> <SEMICOLON><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final VarDeclaration n, final A argu) {
    R nRes = null;
    // f0 -> TypedDeclaration()
    final TypedDeclaration n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> <SEMICOLON>
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link MethodDeclaration} node, whose children are the following :
   * <p>
   * f0 -> <PUBLIC_MODIFIER><br>
   * f1 -> Type()<br>
   * f2 -> Identifier()<br>
   * f3 -> <PARENTHESIS_LEFT><br>
   * f4 -> ( #0 ParameterDeclaration()<br>
   * .. .. . #1 ( $0 <COMMA> $1 ParameterDeclaration() )* )?<br>
   * f5 -> <PARENTHESIS_RIGHT><br>
   * f6 -> <BRACE_LEFT><br>
   * f7 -> ( VarDeclaration() )*<br>
   * f8 -> ( Statement() )*<br>
   * f9 -> ( #0 <RETURN> #1 Expression() #2 <SEMICOLON> )?<br>
   * f10 -> <BRACE_RIGHT><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final MethodDeclaration n, final A argu) {
    R nRes = null;
    // f0 -> <PUBLIC_MODIFIER>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> Type()
    final Type n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> Identifier()
    final Identifier n2 = n.f2;
    nRes = n2.accept(this, argu);
    // f3 -> <PARENTHESIS_LEFT>
    final NodeToken n3 = n.f3;
    nRes = n3.accept(this, argu);
    // f4 -> ( #0 ParameterDeclaration()
    // .. .. . #1 ( $0 <COMMA> $1 ParameterDeclaration() )* )?
    final NodeOptional n4 = n.f4;
    if (n4.present()) {
      final NodeSequence seq = (NodeSequence) n4.node;
      // #0 ParameterDeclaration()
      final INode seq1 = seq.elementAt(0);
      nRes = seq1.accept(this, argu);
      // #1 ( $0 <COMMA> $1 ParameterDeclaration() )*
      final INode seq2 = seq.elementAt(1);
      final NodeListOptional nlo = (NodeListOptional) seq2;
      if (nlo.present()) {
        for (int i = 0; i < nlo.size(); i++) {
          final INode nloeai = nlo.elementAt(i);
          final NodeSequence seq3 = (NodeSequence) nloeai;
          // $0 <COMMA>
          final INode seq4 = seq3.elementAt(0);
          nRes = seq4.accept(this, argu);
          // $1 ParameterDeclaration()
          final INode seq5 = seq3.elementAt(1);
          nRes = seq5.accept(this, argu);
        }
      }
    }
    // f5 -> <PARENTHESIS_RIGHT>
    final NodeToken n5 = n.f5;
    nRes = n5.accept(this, argu);
    // f6 -> <BRACE_LEFT>
    final NodeToken n6 = n.f6;
    nRes = n6.accept(this, argu);
    // f7 -> ( VarDeclaration() )*
    final NodeListOptional n7 = n.f7;
    if (n7.present()) {
      for (int i = 0; i < n7.size(); i++) {
        final INode nloeai = n7.elementAt(i);
        nRes = nloeai.accept(this, argu);
      }
    }
    // f8 -> ( Statement() )*
    final NodeListOptional n8 = n.f8;
    if (n8.present()) {
      for (int i = 0; i < n8.size(); i++) {
        final INode nloeai = n8.elementAt(i);
        nRes = nloeai.accept(this, argu);
      }
    }
    // f9 -> ( #0 <RETURN> #1 Expression() #2 <SEMICOLON> )?
    final NodeOptional n9 = n.f9;
    if (n9.present()) {
      final NodeSequence seq6 = (NodeSequence) n9.node;
      // #0 <RETURN>
      final INode seq7 = seq6.elementAt(0);
      nRes = seq7.accept(this, argu);
      // #1 Expression()
      final INode seq8 = seq6.elementAt(1);
      nRes = seq8.accept(this, argu);
      // #2 <SEMICOLON>
      final INode seq9 = seq6.elementAt(2);
      nRes = seq9.accept(this, argu);
    }
    // f10 -> <BRACE_RIGHT>
    final NodeToken n10 = n.f10;
    nRes = n10.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link ParameterDeclaration} node, whose child is the following :
   * <p>
   * f0 -> TypedDeclaration()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final ParameterDeclaration n, final A argu) {
    R nRes = null;
    // f0 -> TypedDeclaration()
    final TypedDeclaration n0 = n.f0;
    nRes = n0.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link TypedDeclaration} node, whose children are the following :
   * <p>
   * f0 -> Type()<br>
   * f1 -> Identifier()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final TypedDeclaration n, final A argu) {
    R nRes = null;
    // f0 -> Type()
    final Type n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> Identifier()
    final Identifier n1 = n.f1;
    nRes = n1.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link Type} node, whose child is the following :
   * <p>
   * f0 -> . %0 IntArrayType()<br>
   * .. .. | %1 IntType()<br>
   * .. .. | %2 BooleanType()<br>
   * .. .. | %3 VoidType()<br>
   * .. .. | %4 Identifier()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final Type n, final A argu) {
    R nRes = null;
    // f0 -> . %0 IntArrayType()
    // .. .. | %1 IntType()
    // .. .. | %2 BooleanType()
    // .. .. | %3 VoidType()
    // .. .. | %4 Identifier()
    final NodeChoice nch = n.f0;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        // %0 IntArrayType()
        nRes = ich.accept(this, argu);
        break;
      case 1:
        // %1 IntType()
        nRes = ich.accept(this, argu);
        break;
      case 2:
        // %2 BooleanType()
        nRes = ich.accept(this, argu);
        break;
      case 3:
        // %3 VoidType()
        nRes = ich.accept(this, argu);
        break;
      case 4:
        // %4 Identifier()
        nRes = ich.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link Statement} node, whose child is the following :
   * <p>
   * f0 -> . %0 BlockStatement()<br>
   * .. .. | %1 IfStatement()<br>
   * .. .. | %2 WhileStatement()<br>
   * .. .. | %3 PrintStatement()<br>
   * .. .. | %4 AssignmentStatement()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final Statement n, final A argu) {
    R nRes = null;
    // f0 -> . %0 BlockStatement()
    // .. .. | %1 IfStatement()
    // .. .. | %2 WhileStatement()
    // .. .. | %3 PrintStatement()
    // .. .. | %4 AssignmentStatement()
    final NodeChoice nch = n.f0;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        // %0 BlockStatement()
        nRes = ich.accept(this, argu);
        break;
      case 1:
        // %1 IfStatement()
        nRes = ich.accept(this, argu);
        break;
      case 2:
        // %2 WhileStatement()
        nRes = ich.accept(this, argu);
        break;
      case 3:
        // %3 PrintStatement()
        nRes = ich.accept(this, argu);
        break;
      case 4:
        // %4 AssignmentStatement()
        nRes = ich.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link BlockStatement} node, whose children are the following :
   * <p>
   * f0 -> <BRACE_LEFT><br>
   * f1 -> ( Statement() )*<br>
   * f2 -> <BRACE_RIGHT><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final BlockStatement n, final A argu) {
    R nRes = null;
    // f0 -> <BRACE_LEFT>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> ( Statement() )*
    final NodeListOptional n1 = n.f1;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode nloeai = n1.elementAt(i);
        nRes = nloeai.accept(this, argu);
      }
    }
    // f2 -> <BRACE_RIGHT>
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link IfStatement} node, whose children are the following :
   * <p>
   * f0 -> <IF><br>
   * f1 -> <PARENTHESIS_LEFT><br>
   * f2 -> Expression()<br>
   * f3 -> <PARENTHESIS_RIGHT><br>
   * f4 -> Statement()<br>
   * f5 -> <ELSE><br>
   * f6 -> Statement()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final IfStatement n, final A argu) {
    R nRes = null;
    // f0 -> <IF>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> <PARENTHESIS_LEFT>
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> Expression()
    final Expression n2 = n.f2;
    nRes = n2.accept(this, argu);
    // f3 -> <PARENTHESIS_RIGHT>
    final NodeToken n3 = n.f3;
    nRes = n3.accept(this, argu);
    // f4 -> Statement()
    final Statement n4 = n.f4;
    nRes = n4.accept(this, argu);
    // f5 -> <ELSE>
    final NodeToken n5 = n.f5;
    nRes = n5.accept(this, argu);
    // f6 -> Statement()
    final Statement n6 = n.f6;
    nRes = n6.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link WhileStatement} node, whose children are the following :
   * <p>
   * f0 -> <WHILE><br>
   * f1 -> <PARENTHESIS_LEFT><br>
   * f2 -> Expression()<br>
   * f3 -> <PARENTHESIS_RIGHT><br>
   * f4 -> Statement()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final WhileStatement n, final A argu) {
    R nRes = null;
    // f0 -> <WHILE>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> <PARENTHESIS_LEFT>
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> Expression()
    final Expression n2 = n.f2;
    nRes = n2.accept(this, argu);
    // f3 -> <PARENTHESIS_RIGHT>
    final NodeToken n3 = n.f3;
    nRes = n3.accept(this, argu);
    // f4 -> Statement()
    final Statement n4 = n.f4;
    nRes = n4.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link PrintStatement} node, whose children are the following :
   * <p>
   * f0 -> <PRINT_METHOD><br>
   * f1 -> <PARENTHESIS_LEFT><br>
   * f2 -> Expression()<br>
   * f3 -> <PARENTHESIS_RIGHT><br>
   * f4 -> <SEMICOLON><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final PrintStatement n, final A argu) {
    R nRes = null;
    // f0 -> <PRINT_METHOD>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> <PARENTHESIS_LEFT>
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> Expression()
    final Expression n2 = n.f2;
    nRes = n2.accept(this, argu);
    // f3 -> <PARENTHESIS_RIGHT>
    final NodeToken n3 = n.f3;
    nRes = n3.accept(this, argu);
    // f4 -> <SEMICOLON>
    final NodeToken n4 = n.f4;
    nRes = n4.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link AssignmentStatement} node, whose children are the following :
   * <p>
   * f0 -> Assignee()<br>
   * f1 -> <EQUALS_SIGN><br>
   * f2 -> Expression()<br>
   * f3 -> <SEMICOLON><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final AssignmentStatement n, final A argu) {
    R nRes = null;
    // f0 -> Assignee()
    final Assignee n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> <EQUALS_SIGN>
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> Expression()
    final Expression n2 = n.f2;
    nRes = n2.accept(this, argu);
    // f3 -> <SEMICOLON>
    final NodeToken n3 = n.f3;
    nRes = n3.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link Assignee} node, whose child is the following :
   * <p>
   * f0 -> . %0 AssignableArrayAccess()<br>
   * .. .. | %1 Identifier()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final Assignee n, final A argu) {
    R nRes = null;
    // f0 -> . %0 AssignableArrayAccess()
    // .. .. | %1 Identifier()
    final NodeChoice nch = n.f0;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        // %0 AssignableArrayAccess()
        nRes = ich.accept(this, argu);
        break;
      case 1:
        // %1 Identifier()
        nRes = ich.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link AssignableArrayAccess} node, whose children are the following :
   * <p>
   * f0 -> Identifier()<br>
   * f1 -> ArrayAccess()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final AssignableArrayAccess n, final A argu) {
    R nRes = null;
    // f0 -> Identifier()
    final Identifier n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> ArrayAccess()
    final ArrayAccess n1 = n.f1;
    nRes = n1.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link ArrayAccess} node, whose children are the following :
   * <p>
   * f0 -> <BRACKET_LEFT><br>
   * f1 -> Expression()<br>
   * f2 -> <BRACKET_RIGHT><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final ArrayAccess n, final A argu) {
    R nRes = null;
    // f0 -> <BRACKET_LEFT>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> Expression()
    final Expression n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> <BRACKET_RIGHT>
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link Expression} node, whose child is the following :
   * <p>
   * f0 -> . %0 #0 ObjectInstantiationExpression() #1 ExpressionPrime()<br>
   * .. .. | %1 #0 UnaryOperator() #1 Expression() #2 ExpressionPrime()<br>
   * .. .. | %2 #0 <PARENTHESIS_LEFT> #1 Expression() #2 <PARENTHESIS_RIGHT> #3 ExpressionPrime()<br>
   * .. .. | %3 #0 <INTEGER_LITERAL> #1 ExpressionPrime()<br>
   * .. .. | %4 #0 <TRUE> #1 ExpressionPrime()<br>
   * .. .. | %5 #0 <FALSE> #1 ExpressionPrime()<br>
   * .. .. | %6 #0 <THIS> #1 ExpressionPrime()<br>
   * .. .. | %7 #0 Identifier() #1 ExpressionPrime()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final Expression n, final A argu) {
    R nRes = null;
    // f0 -> . %0 #0 ObjectInstantiationExpression() #1 ExpressionPrime()
    // .. .. | %1 #0 UnaryOperator() #1 Expression() #2 ExpressionPrime()
    // .. .. | %2 #0 <PARENTHESIS_LEFT> #1 Expression() #2 <PARENTHESIS_RIGHT> #3 ExpressionPrime()
    // .. .. | %3 #0 <INTEGER_LITERAL> #1 ExpressionPrime()
    // .. .. | %4 #0 <TRUE> #1 ExpressionPrime()
    // .. .. | %5 #0 <FALSE> #1 ExpressionPrime()
    // .. .. | %6 #0 <THIS> #1 ExpressionPrime()
    // .. .. | %7 #0 Identifier() #1 ExpressionPrime()
    final NodeChoice nch = n.f0;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        // %0 #0 ObjectInstantiationExpression() #1 ExpressionPrime()
        final NodeSequence seq = (NodeSequence) ich;
        // #0 ObjectInstantiationExpression()
        final INode seq1 = seq.elementAt(0);
        nRes = seq1.accept(this, argu);
        // #1 ExpressionPrime()
        final INode seq2 = seq.elementAt(1);
        nRes = seq2.accept(this, argu);
        break;
      case 1:
        // %1 #0 UnaryOperator() #1 Expression() #2 ExpressionPrime()
        final NodeSequence seq3 = (NodeSequence) ich;
        // #0 UnaryOperator()
        final INode seq4 = seq3.elementAt(0);
        nRes = seq4.accept(this, argu);
        // #1 Expression()
        final INode seq5 = seq3.elementAt(1);
        nRes = seq5.accept(this, argu);
        // #2 ExpressionPrime()
        final INode seq6 = seq3.elementAt(2);
        nRes = seq6.accept(this, argu);
        break;
      case 2:
        // %2 #0 <PARENTHESIS_LEFT> #1 Expression() #2 <PARENTHESIS_RIGHT> #3 ExpressionPrime()
        final NodeSequence seq7 = (NodeSequence) ich;
        // #0 <PARENTHESIS_LEFT>
        final INode seq8 = seq7.elementAt(0);
        nRes = seq8.accept(this, argu);
        // #1 Expression()
        final INode seq9 = seq7.elementAt(1);
        nRes = seq9.accept(this, argu);
        // #2 <PARENTHESIS_RIGHT>
        final INode seq10 = seq7.elementAt(2);
        nRes = seq10.accept(this, argu);
        // #3 ExpressionPrime()
        final INode seq11 = seq7.elementAt(3);
        nRes = seq11.accept(this, argu);
        break;
      case 3:
        // %3 #0 <INTEGER_LITERAL> #1 ExpressionPrime()
        final NodeSequence seq12 = (NodeSequence) ich;
        // #0 <INTEGER_LITERAL>
        final INode seq13 = seq12.elementAt(0);
        nRes = seq13.accept(this, argu);
        // #1 ExpressionPrime()
        final INode seq14 = seq12.elementAt(1);
        nRes = seq14.accept(this, argu);
        break;
      case 4:
        // %4 #0 <TRUE> #1 ExpressionPrime()
        final NodeSequence seq15 = (NodeSequence) ich;
        // #0 <TRUE>
        final INode seq16 = seq15.elementAt(0);
        nRes = seq16.accept(this, argu);
        // #1 ExpressionPrime()
        final INode seq17 = seq15.elementAt(1);
        nRes = seq17.accept(this, argu);
        break;
      case 5:
        // %5 #0 <FALSE> #1 ExpressionPrime()
        final NodeSequence seq18 = (NodeSequence) ich;
        // #0 <FALSE>
        final INode seq19 = seq18.elementAt(0);
        nRes = seq19.accept(this, argu);
        // #1 ExpressionPrime()
        final INode seq20 = seq18.elementAt(1);
        nRes = seq20.accept(this, argu);
        break;
      case 6:
        // %6 #0 <THIS> #1 ExpressionPrime()
        final NodeSequence seq21 = (NodeSequence) ich;
        // #0 <THIS>
        final INode seq22 = seq21.elementAt(0);
        nRes = seq22.accept(this, argu);
        // #1 ExpressionPrime()
        final INode seq23 = seq21.elementAt(1);
        nRes = seq23.accept(this, argu);
        break;
      case 7:
        // %7 #0 Identifier() #1 ExpressionPrime()
        final NodeSequence seq24 = (NodeSequence) ich;
        // #0 Identifier()
        final INode seq25 = seq24.elementAt(0);
        nRes = seq25.accept(this, argu);
        // #1 ExpressionPrime()
        final INode seq26 = seq24.elementAt(1);
        nRes = seq26.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link ObjectInstantiationExpression} node, whose children are the following :
   * <p>
   * f0 -> <NEW><br>
   * f1 -> ConstructorCall()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final ObjectInstantiationExpression n, final A argu) {
    R nRes = null;
    // f0 -> <NEW>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> ConstructorCall()
    final ConstructorCall n1 = n.f1;
    nRes = n1.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link ConstructorCall} node, whose child is the following :
   * <p>
   * f0 -> . %0 ClassConstructorCall()<br>
   * .. .. | %1 IntArrayConstructorCall()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final ConstructorCall n, final A argu) {
    R nRes = null;
    // f0 -> . %0 ClassConstructorCall()
    // .. .. | %1 IntArrayConstructorCall()
    final NodeChoice nch = n.f0;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        // %0 ClassConstructorCall()
        nRes = ich.accept(this, argu);
        break;
      case 1:
        // %1 IntArrayConstructorCall()
        nRes = ich.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link ClassConstructorCall} node, whose children are the following :
   * <p>
   * f0 -> Identifier()<br>
   * f1 -> <PARENTHESIS_LEFT><br>
   * f2 -> <PARENTHESIS_RIGHT><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final ClassConstructorCall n, final A argu) {
    R nRes = null;
    // f0 -> Identifier()
    final Identifier n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> <PARENTHESIS_LEFT>
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> <PARENTHESIS_RIGHT>
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link IntArrayConstructorCall} node, whose children are the following :
   * <p>
   * f0 -> IntType()<br>
   * f1 -> ArrayAccess()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final IntArrayConstructorCall n, final A argu) {
    R nRes = null;
    // f0 -> IntType()
    final IntType n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> ArrayAccess()
    final ArrayAccess n1 = n.f1;
    nRes = n1.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link ExpressionPrime} node, whose child is the following :
   * <p>
   * f0 -> . %0 #0 BinaryOperator() #1 Expression() #2 ExpressionPrime()<br>
   * .. .. | %1 #0 ArrayAccess() #1 ExpressionPrime()<br>
   * .. .. | %2 #0 ArrayLengthAccess() #1 ExpressionPrime()<br>
   * .. .. | %3 #0 MethodCall() #1 ExpressionPrime()<br>
   * .. .. | %4 Empty()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final ExpressionPrime n, final A argu) {
    R nRes = null;
    // f0 -> . %0 #0 BinaryOperator() #1 Expression() #2 ExpressionPrime()
    // .. .. | %1 #0 ArrayAccess() #1 ExpressionPrime()
    // .. .. | %2 #0 ArrayLengthAccess() #1 ExpressionPrime()
    // .. .. | %3 #0 MethodCall() #1 ExpressionPrime()
    // .. .. | %4 Empty()
    final NodeChoice nch = n.f0;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        // %0 #0 BinaryOperator() #1 Expression() #2 ExpressionPrime()
        final NodeSequence seq = (NodeSequence) ich;
        // #0 BinaryOperator()
        final INode seq1 = seq.elementAt(0);
        nRes = seq1.accept(this, argu);
        // #1 Expression()
        final INode seq2 = seq.elementAt(1);
        nRes = seq2.accept(this, argu);
        // #2 ExpressionPrime()
        final INode seq3 = seq.elementAt(2);
        nRes = seq3.accept(this, argu);
        break;
      case 1:
        // %1 #0 ArrayAccess() #1 ExpressionPrime()
        final NodeSequence seq4 = (NodeSequence) ich;
        // #0 ArrayAccess()
        final INode seq5 = seq4.elementAt(0);
        nRes = seq5.accept(this, argu);
        // #1 ExpressionPrime()
        final INode seq6 = seq4.elementAt(1);
        nRes = seq6.accept(this, argu);
        break;
      case 2:
        // %2 #0 ArrayLengthAccess() #1 ExpressionPrime()
        final NodeSequence seq7 = (NodeSequence) ich;
        // #0 ArrayLengthAccess()
        final INode seq8 = seq7.elementAt(0);
        nRes = seq8.accept(this, argu);
        // #1 ExpressionPrime()
        final INode seq9 = seq7.elementAt(1);
        nRes = seq9.accept(this, argu);
        break;
      case 3:
        // %3 #0 MethodCall() #1 ExpressionPrime()
        final NodeSequence seq10 = (NodeSequence) ich;
        // #0 MethodCall()
        final INode seq11 = seq10.elementAt(0);
        nRes = seq11.accept(this, argu);
        // #1 ExpressionPrime()
        final INode seq12 = seq10.elementAt(1);
        nRes = seq12.accept(this, argu);
        break;
      case 4:
        // %4 Empty()
        nRes = ich.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link ArrayLengthAccess} node, whose children are the following :
   * <p>
   * f0 -> <DOT><br>
   * f1 -> <LENGTH_FIELD_NAME><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final ArrayLengthAccess n, final A argu) {
    R nRes = null;
    // f0 -> <DOT>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> <LENGTH_FIELD_NAME>
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link MethodCall} node, whose children are the following :
   * <p>
   * f0 -> <DOT><br>
   * f1 -> Identifier()<br>
   * f2 -> <PARENTHESIS_LEFT><br>
   * f3 -> ( #0 Parameter()<br>
   * .. .. . #1 ( $0 <COMMA> $1 Parameter() )* )?<br>
   * f4 -> <PARENTHESIS_RIGHT><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final MethodCall n, final A argu) {
    R nRes = null;
    // f0 -> <DOT>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> Identifier()
    final Identifier n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> <PARENTHESIS_LEFT>
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    // f3 -> ( #0 Parameter()
    // .. .. . #1 ( $0 <COMMA> $1 Parameter() )* )?
    final NodeOptional n3 = n.f3;
    if (n3.present()) {
      final NodeSequence seq = (NodeSequence) n3.node;
      // #0 Parameter()
      final INode seq1 = seq.elementAt(0);
      nRes = seq1.accept(this, argu);
      // #1 ( $0 <COMMA> $1 Parameter() )*
      final INode seq2 = seq.elementAt(1);
      final NodeListOptional nlo = (NodeListOptional) seq2;
      if (nlo.present()) {
        for (int i = 0; i < nlo.size(); i++) {
          final INode nloeai = nlo.elementAt(i);
          final NodeSequence seq3 = (NodeSequence) nloeai;
          // $0 <COMMA>
          final INode seq4 = seq3.elementAt(0);
          nRes = seq4.accept(this, argu);
          // $1 Parameter()
          final INode seq5 = seq3.elementAt(1);
          nRes = seq5.accept(this, argu);
        }
      }
    }
    // f4 -> <PARENTHESIS_RIGHT>
    final NodeToken n4 = n.f4;
    nRes = n4.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link Parameter} node, whose child is the following :
   * <p>
   * f0 -> Expression()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final Parameter n, final A argu) {
    R nRes = null;
    // f0 -> Expression()
    final Expression n0 = n.f0;
    nRes = n0.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link UnaryOperator} node, whose child is the following :
   * <p>
   * f0 -> <UNARY_OPERATOR><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final UnaryOperator n, final A argu) {
    R nRes = null;
    // f0 -> <UNARY_OPERATOR>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link BinaryOperator} node, whose child is the following :
   * <p>
   * f0 -> <BINARY_OPERATOR><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final BinaryOperator n, final A argu) {
    R nRes = null;
    // f0 -> <BINARY_OPERATOR>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link BooleanType} node, whose child is the following :
   * <p>
   * f0 -> <BOOLEAN_TYPE><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final BooleanType n, final A argu) {
    R nRes = null;
    // f0 -> <BOOLEAN_TYPE>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link VoidType} node, whose child is the following :
   * <p>
   * f0 -> <VOID_TYPE><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final VoidType n, final A argu) {
    R nRes = null;
    // f0 -> <VOID_TYPE>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link IntType} node, whose child is the following :
   * <p>
   * f0 -> <INT_TYPE><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final IntType n, final A argu) {
    R nRes = null;
    // f0 -> <INT_TYPE>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link IntArrayType} node, whose children are the following :
   * <p>
   * f0 -> <INT_TYPE><br>
   * f1 -> <BRACKET_LEFT><br>
   * f2 -> <BRACKET_RIGHT><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final IntArrayType n, final A argu) {
    R nRes = null;
    // f0 -> <INT_TYPE>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> <BRACKET_LEFT>
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> <BRACKET_RIGHT>
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link Identifier} node, whose child is the following :
   * <p>
   * f0 -> <IDENTIFIER><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final Identifier n, final A argu) {
    R nRes = null;
    // f0 -> <IDENTIFIER>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link Empty} node, whose children are the following :
   * <p>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final Empty n, final A argu) {
    R nRes = null;
    return nRes;
  }

}
